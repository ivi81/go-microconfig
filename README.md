**задать уникальностьзволяетБиблиотека на golang для работы с конфигурацией микросервисов**

***Что умеет данная библиотека***
В данной библиотеке совмещен функционал позволяющий заружать настройки приложения из набора yaml-файлов и переменных окружения среды. Значения настроек в yaml-файлах и переменных среды могут дополнять либо перекрывать друг друга.

***Как установить***

* Установка последней версии
*go get gitlab.cloud.gcm/i.ippolitov/go-microconfig*
* Установка вместе с последним коммитом из main
*go get gitlab.cloud.gcm/i.ippolitov/go-microconfig@main*
* Обновление до последней минорной версии
*go get -u gitlab.cloud.gcm/i.ippolitov/go-microconfig*

Путь к набору yaml-файлов конфигурации задается в переменной окружения "CONFIG\_PATH". Если "CONFIG\_PATH" не задан то библиотека пытается считать файлы из пути по умолчанию "./config"

***Как работает данный модуль***

Как было сказанно выше, модуль читает файлы конфигурации из набора yaml-файлов и переменных окружения среды.

**func Load(cfg any, envPrefix string, verbose bool) error**- главная функция пакета, загружает в переданную в нее структуру данные конфигурацию приложения.

Сначала загружает данные из набора yaml-файлов а затем из переменных окружения названия которых
формируются из envPrefix и значений тега "env" полей заполняемой структуры.

***параметры:***

* **cfg** - ссылка на заполняемую структуру
* **envPrefix** - префикс в названиях перменных окружения (позволяет задать уникальность переменных окружения для экземпляра сервиса)
* **verbose** - включение подробного режима работы функции (результаты выводятся на stdout)

Поля структуры описывающей конфигурацию сервися должны быть дополненны тегами рефлексии ***\`yaml:...\`***(необходимо для Unmarshaling-а yaml-файлов пакетом gopkg.in/yaml.v2) и ***\`env:...\`*** (необходимо для заполнения полей структуры значениями из переменных окружения).

***Поля структуры должны быть следующих типов:***
* int
* float
* tyme.Duration
* string
* []string

***Пример применения данного модуля:***
Cfg := struct{
Field1 string \`yaml:"field1" env:"FIELD1"\`
Field2 int \`yaml:"field2" env:"FIELD2"\`
}

err := microconfig.Load(testCfg, EnvPrefixAsServiceName, true)

***Пример структуры каталогов*** для хранения конфигурации сервиса для разных продуктовых сред

```
./testdata/config/exampleconfig/
├── default
│   └── defaultcfg.yaml
├── development
│   ├── devClienCfg.yaml
│   └── devServerCfg.yaml
├── production
│   └── prodCfg.yaml
└── test
    └── testCfg.yaml
    ....
    и т.д.
```

***Необходимым условием для чтения конфигурации из yaml-файлов является:***
* ***задание двух переменных окружения:***
* ***{{EnvPrefixAsServiceName}}_CONFIG_PATH*** - содержит путь к каталогу хранящему конфигурацию (в примере выше это *"./testdata/config/exampleconfig/"*). Если не задано значение *EnvPrefixAsServiceName* то по умолчанию библиотека читает переменную окружения *CONFIG_PATH*. Если 
* ***STAGE*** - содержит название продуктовой среды для которой необходимо загрузить конфигурацию (если *STAGE* не зада то по умолчанию *STAGE="development"*). Значение этой переменной должно совпадать с названием каталога хранящего конфигурацию (см. пример выше) и должно содержаться в качестве первого элемента файла конфигурации.

* Наличие внутри *CONFIG_PATH* каталога *"default"* - хранящего дефолтную конфигурацию сервиса.

***Структура файла конфигурации*** 
Файл конфигурации является yaml-файлом кторый должен содержать в начале название продуктовой среды заданное в переменной *STAGE*

Например:
```
---
**defaults:**
  client:
    host: client_host1
    port: 3
  server:
      host: server_host
      port: 2
  storage:
    user: db_user
    pwd: db_pwd
    db: local:db
```
или

```
**production:**
  client:
    host: prod_client_host1
  server:
      host: prod_server_host
```
При чтении данной структуры каталогов значения из yaml-файлов дополняют и перекрывают друг друга.
Например в случае если STAGE=test, то 